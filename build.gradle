import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.jlleitschuh.gradle.ktlint.reporter.ReporterType

buildscript {
    apply from: 'gradle/versions.gradle'
    apply from: 'gradle/dependencies.gradle'

    repositories {
        jcenter()
        google()
        gradlePluginPortal()
        maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
        maven { url "http://storage.googleapis.com/r8-releases/raw" }
    }

    dependencies {
        classpath 'com.android.tools:r8:1.3.36'

        classpathDependencies.values().each { classpath it }
    }
}

apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-kapt'

apply plugin: 'com.github.ben-manes.versions'
apply plugin: 'org.jlleitschuh.gradle.ktlint'
apply plugin: 'io.gitlab.arturbosch.detekt'
apply plugin: 'com.novoda.android-command'

android {
    compileSdkVersion rootProject.ext.compileSdkVersion

    dexOptions {
        preDexLibraries !isCI()
    }

    defaultConfig {
        applicationId 'me.proxer.app'
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode appVersionMajor * 1000000 + appVersionMinor * 10000 + appVersionPatch * 100
        versionName "$appVersionMajor.$appVersionMinor.$appVersionPatch"

        vectorDrawables.useSupportLibrary true
        resConfigs 'de'
    }

    sourceSets {
        main {
            java.srcDirs += "src/main/kotlin"
        }

        debug {
            java.srcDirs += "src/debug/kotlin"
        }

        release {
            java.srcDirs += "src/release/kotlin"
        }

        logRelease {
            setRoot "src/release"

            java.srcDirs = release.java.srcDirs
        }
    }

    compileOptions {
        sourceCompatibility javaVersion
        targetCompatibility javaVersion
    }

    signingConfigs {
        if (shouldSign()) {
            release {
                storeFile file(getFromSecrets('RELEASE_STORE_FILE'))
                storePassword getFromSecrets('RELEASE_STORE_PASSWORD')
                keyAlias getFromSecrets('RELEASE_KEY_ALIAS')
                keyPassword getFromSecrets('RELEASE_KEY_PASSWORD')
            }
        }
    }

    buildTypes {
        boolean shouldSign = shouldSign() && !isCI()

        if (!shouldSign) {
            logger.warn('This build will not be signed because it is missing the keystore info. Please add ' +
                    'values for "RELEASE_STORE_FILE", "RELEASE_STORE_PASSWORD", "RELEASE_KEY_ALIAS" and ' +
                    '"RELEASE_KEY_PASSWORD" to your secrets.properties file if you want the apk to be signed.')
        }

        debug {
            multiDexEnabled true

            versionNameSuffix = "-debug-${getGitHash()}"
            buildConfigField 'String', 'PROXER_API_KEY', "\"${getFromSecrets('PROXER_API_KEY')}\""
            buildConfigField 'boolean', 'LOG', "Boolean.parseBoolean(\"true\")"
        }

        release {
            postprocessing {
                removeUnusedCode true
                removeUnusedResources true
                obfuscate true
                optimizeCode true
                proguardFile 'config/proguard/proguard-rules.pro'
            }

            buildConfigField 'String', 'PROXER_API_KEY', "\"${getFromSecrets('PROXER_API_KEY')}\""
            buildConfigField 'boolean', 'LOG', "Boolean.parseBoolean(\"false\")"

            if (shouldSign) {
                signingConfig signingConfigs.release
            }
        }

        logRelease {
            postprocessing {
                removeUnusedCode true
                removeUnusedResources true
                obfuscate true
                optimizeCode true
                proguardFile 'config/proguard/proguard-rules.pro'
            }

            versionNameSuffix = "-logRelease-${getGitHash()}"
            buildConfigField 'String', 'PROXER_API_KEY', "\"${getFromSecrets('PROXER_API_KEY')}\""
            buildConfigField 'boolean', 'LOG', "Boolean.parseBoolean(\"true\")"

            if (shouldSign) {
                signingConfig signingConfigs.release
            }
        }
    }

    lintOptions {
        mkdir("$buildDir/reports/lint")

        warningsAsErrors = true

        lintConfig file("$rootDir/config/lint/lint.xml")
        xmlOutput file("$buildDir/reports/lint/lint-results.xml")
        htmlOutput file("$buildDir/reports/lint/lint-results.html")
    }

    packagingOptions {
        exclude 'META-INF/*.kotlin_module'
        exclude 'META-INF/*.version'
        exclude 'META-INF/rxkotlin.properties'
        exclude 'META-INF/proguard/**'
        exclude 'kotlin/**'
        exclude 'third_party/**'
        exclude 'jsr305_annotations/**'
        exclude 'error_prone/**'
        exclude 'protobuf.meta'
        exclude 'build-data.properties'
        exclude 'androidsupportmultidexversion.txt'
    }

    applicationVariants.all { variant ->
        def suffix = variant.buildType.name == "release" ? "-release" : ""

        variant.outputs.all {
            outputFileName = "app-${variant.versionName}${suffix}.apk"
        }
    }

    if (isCI()) {
        // We do not care for these build types on CI.
        // These do only add a large amount of build time while not providing a large benefit.
        variantFilter { variant ->
            if (variant.buildType.name == "logRelease") {
                setIgnore(true)
            }
        }
    }
}

repositories {
    jcenter()
    google()
    maven { url 'https://jitpack.io' }
    maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
}

dependencies {
    implementationDependencies.values().each { implementation it }
    debugImplementationDependencies.values().each { debugImplementation it }
    releaseImplementationDependencies.values().each { releaseImplementation it }
    releaseImplementationDependencies.values().each { logReleaseImplementation it }
    compileOnlyDependencies.values().each { compileOnly it }
    kaptDependencies.values().each { kapt it }
    testDependencies.values().each { testImplementation it }

    excludingImplementationDependencies.values().each { dependency ->
        implementation(dependency.dependency) {
            dependency.exclusions.each {
                exclude module: it
            }
        }
    }
}

kapt {
    useBuildCache = true
}

detekt {
    version = detektPluginVersion
    parallel = true

    config = files("$projectDir/config/detekt/detekt.yml")
    input = files("$projectDir/src/main/kotlin")

    reports {
        xml.destination = file("$buildDir/reports/detekt/detekt.xml")
        html.destination = file("$buildDir/reports/detekt/detekt.html")
    }
}

ktlint {
    version = ktlintVersion
    reporters = [ReporterType.CHECKSTYLE]
}

wrapper {
    gradleVersion rootProject.ext.gradleVersion
}

tasks.withType(KotlinCompile).all {
    kotlinOptions {
        freeCompilerArgs = ["-Xjsr305=strict", "-progressive"]
    }
}

static getGitHash() {
    String gitRevParseCommand = "git rev-parse --verify --short HEAD"

    return gitRevParseCommand.execute().text.trim()
}

static String getFromSecrets(String key) {
    if (isCI()) {
        return 'dummy'
    }

    Properties result = new Properties()

    try {
        result.load(new FileInputStream(new File('secrets.properties')))
    } catch (Exception ignored) {
        throw new GradleException("Please add a secrets.properties file with a value for $key to perform this action.")
    }

    if (!result.containsKey(key)) {
        throw new GradleException("Please include a value for $key in your secrets.properties " +
                "file to perform this action.")
    }

    return result[key]
}

static boolean shouldSign() {
    Properties result = new Properties()

    try {
        result.load(new FileInputStream(new File('secrets.properties')))
    } catch (Exception ignored) {
        return false
    }

    return result.containsKey('RELEASE_STORE_FILE') && result.containsKey('RELEASE_STORE_PASSWORD') &&
            result.containsKey('RELEASE_KEY_ALIAS') && result.containsKey('RELEASE_KEY_PASSWORD')
}

static boolean isCI() {
    Object isCI = System.getenv('CI')

    return isCI != null && isCI.toBoolean()
}
